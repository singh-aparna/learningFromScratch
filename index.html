<!DOCTYPE html>
<!-- declares the document type as HTML5, ensuring the browser renders the page in standards-compliant mode. -->
<!--HTML5 introduces modern features, better semantics, multimedia support, and cross-platform compatibility
for building robust web applications.-->
<html>

<head>
    <link rel="stylesheet" href="style.css">
    </link>
    <script src="index.js" defer></script>
    <script src="./client/JS files/PromiseAll.js" defer></script>

    <!-- <script src="destructuring.js" defer></script> -->
    <!-- <script src="forLoop.js" defer></script> -->
    <!-- <script src="closure.js" defer></script> -->
    <!-- <script src="objectMethod.js" defer></script> -->
    <!-- <script src="arrayMethod.js" defer></script> -->

    <!-- When you place the <script> tag in the <head> section, the script executes before the HTML elements 
        are fully loaded, so it cannot find or modify elements like <h1> because they don't exist in the DOM yet. -->
    <!-- The defer attribute in a <script> tag delays script execution until the HTML document is fully parsed,
        ensuring scripts run after the DOM is loaded. -->
    <!-- Defer ensurs scripts run after the DOM is loaded. -->
</head>

<body>
    <main class="container">
        <!-- <h1 id="h1">Hello, world!</h1>
        <h2 id="h2">Hello, world!</h2>
        <h2 class="h3">Hello, world!</h2>
        <h2 class="h3">Hello, world!</h2> -->
        <h2>https://api.freeapi.app/</h2>
        <h2>https://mockaroo.com/</h2>
        <ol class="items">
            <li>
                <h2>What is 'fs'? (asked in interview)</h2>
                <p>'fs' is a node.js built-in module for handling file system operations. </p>
            </li>

            <li>
                <h2>What is 'ajax'? (asked in interview)</h2>
                <p>'ajax' (Asynchronous Javascript and XML) It's a technique or a way for web-page for sending and
                    receiving data
                    from a server asynchronously w/o reloading the page. </p>
            </li>

            <li>
                <h2>What is 'API'? (asked in interview)</h2>
                <p>API (Application Programming Interface) is a set of rules that allows different software
                    applications to communicate with each other. </p>
                • example github user's api<br />
                • What it does:<br />
                • Sends a request to GitHub's API to get details of the user "octocat".<br />
                • Returns data like username, profile image, bio, and more in JSON format.<br />
                • How API Enables Communication:<br />
                • The food app (client) sends a request to Google Maps API (server).<br />
                • Google Maps API processes the request and returns a response with location data.<br />
                • The food app uses this response to show real-time restaurant locations.
            </li>

            <li>
                <h2>Difference b/w res.json() & res.send().</h2>
                <p>res.json() automatically sets the Content-Type to application/json and converts the response to JSON,
                    while res.send() can send any type of response (string, object, buffer, etc.). </p>
            </li>

            <li>
                <h2>Difference b/w req.body & req.params. (asked in interview)</h2>
                <p>req.body contains data sent in the request body (used in POST or PUT),
                    while req.params holds route parameters from the URL (e.g., /user/:id). </p>
            </li>

            <li>
                <h2>What is Node.js? (asked in interview)</h2>
                <p>Node.js is a runtime environment that allows you to run JavaScript on the server-side using the v8
                    engine.
                </p>
            </li>

            <li>
                <h2>What is runtime environment?</h2>
                <p>A runtime environment provides the necessary tools,
                    libraries, and execution context for running code outside its original development environment. </p>
            </li>

            <li>
                <h2>What is V8 engine?</h2>
                <p>The V8 engine is Google's high-performance JavaScript engine that compiles JavaScript into machine
                    code
                    for
                    faster execution. </p>
            </li>

            <li>
                <h2>How does Nodejs works? (asked in interview)</h2>
                <p>Node.js works by using the V8 engine to execute JavaScript code,
                    along with an event-driven,
                    non-blocking I/O model
                    to handle multiple requests efficiently.</p>
            </li>

            <li>
                <h2>What is event driven & non blocking I/O model? (asked in interview)</h2>
                <p>The event-driven, non-blocking I/O model in Node.js allows it to handle multiple requests
                    asynchronously
                    using callbacks,
                    Promises, or async/await,
                    without waiting for one task to complete before starting another.</p>
            </li>

            <li>
                <h2>How does Node.js handle asynchronous operations? (asked in interview)</h2>
                <p>Node.js handles asynchronous operations using an event loop,
                    callbacks, Promises,
                    and async/await,
                    enabling non-blocking execution for efficient performance. </p>
            </li>

            <li>
                <h2>What is Express.js? (asked in interview)</h2>
                <p>Express.js is a Node.js framework for building api and web servers.<br />
                    example - <br />
                    • creating basic server // const express = require('express'), app = express(); app.get('/', (req,
                    res) => res.send('Hello World')); app.listen(3000);<br />
                    • serving JSON // app.get('/api', (req, res) => res.json({ message: 'API response' }));<br />
                    • Route with parameters // app.get('/user/:id', (req, res) => res.send(`User ID:
                    ${req.params.id}`)); </p>
            </li>

            <li>
                <h2>How does jwt token works? (asked in interview)</h2>
                <p>Summary in Simple Terms<br />
                    The server creates a token, signs it with a secret key, and gives it to the client.<br />
                    The client sends the token back with each request.<br />
                    The server verifies the token to ensure it’s valid and processes the request.<br />
                    It’s like an ID card: the client shows it to prove who they are, and the server checks its
                    authenticity!</p>
            </li>

            <li>
                <h2>useEffect Dependency (asked in interview)</h2>
                <p>No dependency (useEffect(callback)) → Runs after every render.<br />
                    Empty array (useEffect(callback, [])) → Runs only once after the initial render, similar to
                    componentDidMount in class components.<br />
                    With dependencies (useEffect(callback, [dep1, dep2])) → Runs after the initial render and whenever
                    any dependency changes.</p>
            </li>

            <li>
                <h2>What next() does in a middleware? (asked in interview)</h2>
                <p>In middleware, next is a function that passes control to the next middleware in the stack; if not
                    called, the request will hang.</p>
            </li>

            <li>
                <h2>How does JWT authentication work in Node.js?</h2>
                <p>JWT authentication in Node.js works by generating a token with user data,
                    signing it with a secret, and then using that token to authenticate subsequent requests without
                    storing session data. 🚀
                </p>
            </li>

            <li>
                <h2>What is CORS, and how do you enable it in Node.js? (asked in interview)</h2>
                <p>CORS (Cross-Origin Resource Sharing) allows or restricts web applications from making requests to
                    domains outside their own,
                    and it can be enabled in Node.js using the cors middleware. 🚀</p>
            </li>


            <li>
                <h2>useMemo hook (asked in interview)</h2>
                <p>useMemo is a React hook that memoizes the result of a function,
                    preventing unnecessary recalculations and improving performance by only recomputing when
                    dependencies change. 🚀</p>
            </li>


            <li>
                <h2>What is TypeScript? (asked in interview)</h2>
                <p>
                    TypeScript is a superset of JavaScript that adds static typing and other features to enhance
                    development and code quality.<br />
                    - Key Points:<br />
                    <b>Static Typing</b>: In TypeScript, you can declare the data types of variables and function
                    parameters
                    (string, number, etc.).<br />
                    <b>Type Safety</b>: It helps catch errors at compile time instead of runtime, making your code more
                    reliable.
                </p>
            </li>

            <li>
                <h2>What is the difference between synchronous and asynchronous code in Node.js?</h2>
                <p>Synchronous code in Node.js executes tasks sequentially, blocking the next task until the current one
                    finishes,
                    while asynchronous code allows tasks to execute non-blocking and in parallel, improving performance.
                </p>
            </li>


            <li>
                <h2>Explain the concept of middleware in Express.js. (asked in interview)</h2>
                <p>Middleware is software that acts as a bridge,
                    processing requests and responses between the client and server or between different application
                    layers.
                </p>
            </li>

            <li>
                <h2>How do you handle errors in Node.js?</h2>
                <p>Errors in Node.js are handled using try...catch (for synchronous code),
                    .catch() (for Promises), and error-first callbacks or process.on('uncaughtException') for global
                    errors. </p>
            </li>

            <li>
                <h2>What is the difference between CommonJS and ES modules?</h2>
                <p>CommonJS (require/module.exports) is used in Node.js for synchronous module loading,
                    while ES Modules (import/export) support asynchronous loading and are the modern JavaScript
                    standard.</p>
            </li>

            <li>
                <h2>Event Loop (asked in interview)</h2>
                <p>The Event Loop in Node.js is a mechanism that handles asynchronous operations
                    by continuously checking and executing
                    pending tasks in the callback queue. 🚀</p>
            </li>

            <li>
                <h2>Does JS event loop and node.js event loop both are same?</h2>
                <p>The Node.js event loop has extra phases to manage asynchronous I/O, timers, and worker threads, while
                    the browser event loop primarily deals with UI rendering, event listeners, and network requests.</p>
            </li>

            <li>
                <h2>Difference b/w parameters & arguments.</h2>
                <p>- Parameters exist in function definitions.<br />
                    - Arguments are the real values passed when invoking a function.</p>
            </li>

            <li>
                <h2>useSelector? (asked in interview)</h2>
                <p>
                    useSelector is a React-Redux hook that selects and retrieves state from the Redux store in a
                    functional component.</p>
            </li>

            <li>
                <h2>body-parser? (asked in interview)</h2>
                <p>body-parser is a middleware in Express
                    that parses incoming request bodies in various formats (such as JSON, URL-encoded) and makes the
                    data accessible in req.body.</p>
            </li>

            <li>
                <h2>cookie-parser? (asked in interview)</h2>
                <p>cookie-parser is a middleware in Express that parses cookies
                    attached to the incoming requests and populates req.cookies with the cookies as key-value pairs.</p>
            </li>

            <li>
                <h2>payload?</h2>
                <p>A payload is the data or information sent in a request or response, often in the body of HTTP
                    requests or within a token like a JWT.</p>
            </li>

            <li>
                <h2>Axios vs fetch (asked in interview)</h2>
                <p>Axios and Fetch are HTTP clients used for making requests to servers.<br />
                    - Fetch is the native browser API, built in JS function => used to make http request => adhering to
                    modern promise-based standards.<br />
                    - Axios is a widely-used third-party library renowned for its concise syntax and extensive feature
                    set.<br />

                    - Axios is generally better due to its simplicity,
                    built-in features like automatic JSON parsing, request/response interceptors(Middleware), and
                    broader browser compatibility.
                    compared to Fetch.</p>
            </li>

            <li>
                <h2>Lexical scope (asked in interview)</h2>
                <p>Lexical scoping is a programming language feature where the scope of a variable is determined by its
                    position in the source code, and it is defined by the stucture of the code, not by the runtime flow
                    of the program.</p>
            </li>

            <li>
                <h2>Closure? (asked in interview)</h2>
                <p>A closure is a function that remembers and accesses variables from its outer scope, even after the
                    outer function has finished executing.<br />
                    this means the function has access to variables in its lexical environment.
                </p>
            </li>

            <li>
                <h2>Logistic Tracking System</h2>
                <p>- Implemented authentication using JWT & bcrypt.js,<br />
                    - handled authentication & protected routes using React Router,<br />
                    - and developed APIs using Express.js and Node.js.<br />
                    - Integrated real-time tracking with webSockets to display vehicle status, speed, and geofence
                    alerts efficiently.</p>
            </li>

            <li>
                <h2>Web sockets?</h2>
                <p>Web socket is a two-way communication channel protocol.<br />
                    between a web-browser & a server that allows real time data transfer like online chat, gaming,
                    live-streming.
                </p>
            </li>

            <li>
                <h2>Web hook?</h2>
                <p>A webhook is a user-defined http callback for event notifications, often
                    used in web-development for real time data transfer.
                </p>
            </li>

            <li>
                <h2>useState & useEffect (asked in interview)</h2>
                <p>useState - in functional component used for state management<br />
                    useEffect - It replaces react life cycle method in functional componenets & to handle side effects
                    for
                    api calls</p>
            </li>

            <li>
                <h2>app.use(express.json()) vs app.use(express.urlencoded({ extended: false }))</h2>
                <p>
                    <b>app.use(express.json())</b><br />
                    Parses incoming JSON requests.<br />
                    Required for handling Content-Type: application/json in POST/PUT requests.<br />

                    <b>app.use(express.urlencoded({ extended: false }))</b>
                    Parses application/x-www-form-urlencoded data (like form submissions).<br />
                    If extended: false, it only supports simple key-value pairs.<br />
                    If extended: true, it allows nested objects.
                </p>
            </li>

            <li>
                <h2>CSR vs SSR (asked in interview)</h2>
                <p>CSR - Client Side Rendering - React - slow //Server will provide raw data and client will process
                    that accordingly to screen sizes<br />
                    SSR - Server Side Rendering (Fast) - Google/Youtube //server will render itself html document</p>
            </li>

            <li>
                <h2>Method</h2>
                <p>A method is a function associated with an object that performs an action when invoked on that object.
                </p>
            </li>

            <li>
                <h2>Important Middleware Used in Industry-Level Node.js Applications</h2>
                <p>express.json() & express.urlencoded({ extended: true }) – Parses incoming JSON and URL-encoded data.
                    <br />
                    cors – Enables Cross-Origin Resource Sharing for APIs.<br />
                    helmet – Enhances security by setting HTTP headers.<br />
                    morgan – Logs HTTP requests for debugging and monitoring.<br />
                    compression – Compresses response data for better performance.<br />
                    cookie-parser – Parses cookies from client requests.<br />
                    express-session – Manages user sessions in applications.<br />
                    rate-limit – Implements request rate-limiting for security.<br />
                    passport – Handles authentication strategies like JWT, OAuth, etc.<br />
                    multer – Handles file uploads in APIs.<br />
                    error-handling middleware – Custom middleware to catch and handle errors globally.<br />
                    These are widely used in RESTful APIs, authentication, security, and performance optimization in
                    production-grade applications. 🚀
                </p>
            </li>

            <li>
                <h2>What are Recat hooks? (asked in interview)</h2>
                <p><b>React Hooks are functions that let you use state and lifecycle features</b> in functional
                    components
                    without writing a class.</p>
            </li>

            <li>
                <h2>What are the advantages of using hooks over class components?</h2>
                <p><b>Easier State Management</b> – useState, useEffect, etc., make managing state and side effects
                    simpler.<br />
                    <b>No this Keyword</b> – Avoids confusion caused by this in class components.<br />
                    <b>Reusability</b> – Custom hooks allow code reuse across components.<br />
                    <b>Improved Component Structure</b> – No need for lifecycle methods like componentDidMount,
                    componentDidUpdate, etc.
                </p>
            </li>

            <li>
                <h2>What is the `useState` hook? (asked in interview)</h2>
                <p>In functional componenet <b>used for state management</b>.</p>
            </li>

            <li>
                <h2>What is the `useEffect` hook? (asked in interview)</h2>
                <p>It replaces react life cycle method in functional componenets & handles side effects for
                    api calls</p>
            </li>

            <li>
                <h2>What are some use cases for `useEffect`?</h2>
                <p>useEffect is used for side effects like fetching data, updating the DOM, handling subscriptions, and
                    managing timers in React components.</p>
            </li>


            <li>
                <h2>What is `useContext` and how does it work? (asked in interview)</h2>
                <p>useContext is a React Hook that allows components to access and consume context values directly
                    without prop drilling.</p>
            </li>

            <li>
                <h2>What is the `useReducer` hook and when would you use it?</h2>
                <p>useReducer is a React Hook used for managing complex state logic by dispatching actions, often
                    preferred over useState for handling state transitions in large applications.</p>
            </li>

            <li>
                <h2> What is the `useMemo` hook? (asked in interview)</h2>
                <p>
                    useMemo is a React Hook that memoizes the result of a function to optimize performance by
                    recomputing only when dependencies change.</p>
            </li>

            <li>
                <h2>What is the React.memo()? (asked in interview)</h2>
                <p>React.memo() is a higher-order component that optimizes functional components by memoizing them,
                    preventing re-renders unless props change.</p>
            </li>

            <li>
                <h2> What is the `useCallback` hook?</h2>
                <p>
                    The useCallback hook memoizes a function to prevent unnecessary re-creations on every render,
                    improving performance in React components.</p>
            </li>

            <li>
                <h2>What are the rules of hooks?</h2>
                <p>The rules of hooks are: Only call hooks at the top level of a component<br />
                    Only call hooks from React function components</p>
            </li>

            <li>
                <h2>What is the `useRef` hook and how does it differ from `useState`?</h2>
                <p>
                    useRef creates a mutable reference to an element or value that persists across renders, while
                    useState stores a value that triggers re-rendering when updated.</p>
            </li>

            <li>
                <h2>What is `useLayoutEffect` and how is it different from `useEffect`?</h2>
                <p>useLayoutEffect is a React Hook that works similarly to useEffect, but it fires synchronously after
                    all DOM mutations and before the browser paints the screen. This means:<br />

                    It runs before the user sees any changes on the screen.<br />
                    <b>It blocks the rendering until it finishes execution.</b>
                </p>
            </li>

            <li>
                <h2>What are custom hooks in React? (asked in interview)</h2>
                <p>Custom hooks in React are reusable functions that encapsulate logic using React hooks (useState,
                    useEffect, etc.) to share stateful behavior across components. 🚀</p>
            </li>

            <li>
                <h2>What is `useImperativeHandle` and how does it work?</h2>
                <p>useImperativeHandle is a React hook that allows a parent component to customize and expose specific
                    methods of a child component's ref, controlling its behavior from outside. 🚀</p>
            </li>

            <li>
                <h2>What are Controlled vs Uncontrolled components? (asked in interview)</h2>
                <p>Controlled components: React controls the form state using useState (value & onChange).<br />
                    Uncontrolled components: The DOM handles the state using ref (defaultValue & useRef). 🚀</p>
            </li>

            <li>
                <h2>What is a Higher Order Component? (asked in interview)</h2>
                <p>A Higher Order Component (HOC) is a function that takes a component as input and returns a new
                    enhanced component with additional props or behavior. 🚀</p>
            </li>

            <li>
                <h2>What is a virtual DOM, how is it different from a real DOM and how it works? (asked in interview)
                </h2>
                <p>
                    The Virtual DOM (VDOM) is a lightweight, in-memory representation of the real DOM that React uses to
                    efficiently update only the changed parts, instead of re-rendering the entire UI, improving
                    performance. 🚀</p>
            </li>

            <li>
                <h2>What is the difference between componentDidMount and useEffect? (asked in interview)</h2>
                <p>componentDidMount is a class component lifecycle method that runs once after the component mounts,
                    while useEffect is a hook in functional components that can run after the render and optionally be
                    triggered on specific state/prop changes. 🚀</p>
            </li>

            <li>
                <h2>What is React fragments?</h2>
                <p>React Fragments (<></>) allow you to group multiple elements without adding an extra DOM node,
                    helping to return multiple children from a component without extra wrapper elements. 🚀</p>
            </li>

            <li>
                <h2>What is JSX? (asked in interview)</h2>
                <p>JSX is a syntax extension for JavaScript that allows you to write HTML-like code within JavaScript,
                    which React then compiles into React elements. 🚀</p>
            </li>

            <li>
                <h2>What is prop and what is prop drilling and what is solution to avoid prop drilling? (asked in
                    interview)</h2>
                <p>Props are data passed from a parent component to a child component; prop drilling is the process of
                    passing props through many layers of components, and the solution is to use Context API or state
                    management libraries (like Redux) to avoid unnecessary drilling. 🚀</p>
            </li>

            <li>
                <h2>What is Context in React?</h2>
                <p>Context in React is a way to share values (like state) across components without passing them
                    explicitly through each level of the component tree. 🚀</p>
            </li>

            <li>
                <h2>What are various ways to style a React app?</h2>
                <p>You can style a React app using CSS files, inline styles, CSS modules, styled-components, or tailwind
                    CSS. 🚀</p>
            </li>

            <li>
                <h2>What are render props in React?</h2>
                <p>Render props in React are a pattern where a component accepts a function as a prop to dynamically
                    render content, allowing code reuse and customization. 🚀</p>
            </li>

            <li>
                <h2>What is headers? (asked in interview)</h2>
                <p>
                    Headers are key-value pairs sent in HTTP requests or responses that provide metadata, such as
                    content type, authentication, or caching information. 🚀</p>
            </li>

            <li>
                <h2>Difeerence between git fetch and git pull. (asked in interview)</h2>
                <p>git fetch retrieves updates from a remote repository without merging them into the local branch,
                    while git pull fetches updates and automatically merges them into the local branch. 🚀</p>
            </li>


            <li>
                <h2>Why do we do npm init?</h2>
                <p>npm init is used to initialize a new Node.js project by creating a package.json file.</p>
            </li>

            <li>
                <h2>What is a Module in Node.js?</h2>
                <p>A module in Node.js is a reusable block of code that can be imported and exported between files to
                    keep the code organized and maintainable.</p>
            </li>

            <li>
                <h2>Explain the primary distinction between the Array.forEach() loop and Array.map() method, as well as
                    when to choose one over the other.</h2>
                <p><b>🔍 Array.forEach():</b><br />
                    It's a method that iterates over each element in an array and performs a specified action (callback
                    function) for each element.<br />
                    The main purpose of forEach() is to execute a function for its side effects, such as logging values,
                    updating variables, or performing operations on the array
                    elements without creating a new array.<br />
                    It does not return anything. It simply iterates over the array and executes the provided function
                    for each element.<br />
                    <b>Array.map():</b><br />
                    It's a method that iterates over each element in an array, applies a transformation function to each
                    element, and returns a new array containing the transformed
                    elements.<br />
                    The main purpose of map() is to create a new array with modified elements based on the original
                    array, without mutating the original array.<br />
                    It returns a new array with the same length as the original array, where each element is the result
                    of applying the provided function to the corresponding element
                    in the original array.
                </p>
            </li>

            <li>
                <h2>Polyfills (asked in interview)</h2>
                <p>Polyfills are code snippets that provide the implementation of certain functionality in older
                    JavaScript environments that do not support it natively.
                    JavaScript polyfills are essential for deep diving into how built-in methods work.<br />
                    Here’s how to approach writing polyfills like a pro:<br />
                    🔥 Step-by-Step Guide to Writing Polyfills:<br />

                    ✅ Identify Inputs & Outputs → What arguments does the method take? What should it return?<br />
                    ✅ Determine Ownership → Is it an Array, Object, Function, or Promise method?<br />
                    ✅ Understand the Logic → Analyze how the native method works.<br />
                    ✅ Draft a Skeleton → Structure your function before implementing logic.<br />
                    ✅ Test Use Cases → Write examples to verify the behavior.<br />
                    ✅ Write the Full Polyfill → Implement it from scratch.<br />
                    ✅ Compare with Native Methods → Ensure it matches native functionality.<br />
                    🏆 Must-Know Polyfills for Frontend Engineers<br />
                    🔥 Promise-based Polyfills:<br />
                    🔹 Promise.all<br />
                    🔹 Promise.allSettled<br />
                    🔹 Promise.race<br />
                    🔥 React-like Hooks Polyfills:<br />
                    🔹 useState<br />
                    🔹 useEffect<br />
                    🔹 useMemo<br />
                    🔹 Redux<br />
                    🔥 Essential JS Methods:<br />
                    🔹 Function.bind<br />
                    🔹 Array.reduce<br />
                    🔹 Object.freeze & Object.seal<br />
                    🔹 Debounce & Throttle<br />
                    🔥 Advanced:<br />
                    🔹 Custom setInterval (Stop, Resume, Pause)<br />
                    🔹 Polyfill for new keyword<br />
                    🔹 Function Memoization (Cache results & optimize performance)
                </p>
            </li>

            <li>
                <h2>Polyfill for Promise.all with Example (asked in interview)</h2>
                <p>The Promise.all method takes an array of promises and resolves when all of them are resolved. If any
                    promise fails, it rejects immediately.</p>
            </li>

            <li>
                <h2>What is API call? (asked in interview)</h2>
                <p>An API call is a request made by a client to a server to retrieve or send data, typically over HTTP
                    using methods like GET, POST, PUT, or DELETE.</p>
            </li>


            <li>
                <h2>Definition and key difference of Promise.all, Promise.allSetteled, Promise.race and Promise.any.
                </h2>
                <p><b>Promise.all</b> → Resolves when all promises succeed, rejects immediately if any fail.<br />
                    <b>Promise.allSettled</b> → Waits for all promises to settle (either resolve or reject), always
                    returns an array of results.<br />
                    <b>Promise.race</b> → Resolves or rejects as soon as the first promise settles, ignoring
                    others.<br />
                    <b>Promise.any</b> → Resolves when any one promise succeeds, rejects only if all fail.
                </p>
            </li>

            <li>
                <h2>In which scenarios do error boundaries not catch errors? </h2>
                <p>Error boundaries do not catch errors inside event handlers, asynchronous code (e.g., setTimeout,
                    fetch), server-side rendering (SSR), or errors thrown inside the error boundary itself.</p>
            </li>


            <li>
                <h2>What is error boundary?</h2>
                <p>An error boundary is a React component that catches JavaScript errors in its child components during
                    rendering, lifecycle methods, and constructors, preventing the entire app from crashing.
                </p>
            </li>


            <li>
                <h2>Can you describe the `componentDidCatch` lifecycle method?</h2>
                <p>The componentDidCatch lifecycle method in React is used inside error boundaries to catch JavaScript
                    errors in child components and log or handle them gracefully.
                </p>
            </li>


            <li>
                <h2>What is the proper placement for error boundaries? </h2>
                <p>Error boundaries should be placed around critical UI components, such as layouts, routes, widgets,
                    and third-party components, to prevent the entire app from crashing.
                </p>
            </li>


            <li>
                <h2>Use case of all promises Promise.all, Promise.allSetteled, Promise.race and Promise.any</h2>
                <p><b>Promise.all</b> → Fetching data from multiple APIs (e.g., user info, posts, comments) where all
                    responses
                    are required.<br />
                    <b>Promise.allSettled</b> → Running multiple analytics events where failures should be logged but
                    not break
                    the process.<br />
                    <b>Promise.race</b> → Implementing a timeout for API requests by racing the request against a
                    fallback
                    timeout promise.<br />
                    <b>Promise.any</b> → Fetching data from multiple redundant servers and using the fastest successful
                    response.
                </p>
            </li>


            <li>
                <h2>Code Splitting</h2>
                <p>Break down large bundles into smaller chunks to reduce initial load times<br />
                    Code splitting is a technique to dynamically load JavaScript only when needed, improving
                    performance.
                </p>
            </li>


            <li>
                <h2>Lazy Loading</h2>
                <p>Load non-essential components\asynchronously to prioritize critical content.
                </p>
            </li>



            <li>
                <h2>Caching and Memoization</h2>
                <p>Cache data locally or use memoization libraries to avoid redundant API calls and computations.
                </p>
            </li>


            <li>
                <h2>Memoization</h2>
                <p>Memoize expensive computations and avoid unnecessary re-renders using tools like React.memo and
                    useMemo.
                </p>
            </li>


            <li>
                <h2>Optimized Rendering</h2>
                <p>Use shouldComponentUpdate, PureComponent, or React.memo to prevent unnecessary re-renders of
                    components.
                </p>
            </li>


            <li>
                <h2>Pure function</h2>
                <p>A pure function is a function that always returns the same output for the same input and has no side
                    effects (does not modify external state). 🚀<br />
                    A pure function does not rely on or modify global variables, ensuring that its output depends only
                    on its input parameters, making it predictable and testable. 🚀
                </p>
            </li>


            <li>
                <h2>Pure Component (asked in interview)</h2>
                <p>A Pure Component in React is a component that only re-renders when its state or props change, using
                    shallow comparison to optimize performance. 🚀
                </p>
            </li>


            <li>
                <h2>Virtualization</h2>
                <p> Implement virtual lists and grids to render only the visible elements, improving rendering
                    performance for large datasets.
                </p>
            </li>


            <li>
                <h2>Server-Side Rendering (SSR)</h2>
                <p>Pre-render content on the server to improve initial page load times and enhance SEO.
                </p>
            </li>


            <li>
                <h2>Bundle Analysis</h2>
                <p>Identify and remove unused dependencies, optimize images, and minify code to reduce bundle size.
                </p>
            </li>


            <li>
                <h2>Performance Monitoring</h2>
                <p>Continuously monitor app performance using tools like Lighthouse, Web Vitals, and browser DevTools.
                </p>
            </li>


            <li>
                <h2>Optimize rendering with keys</h2>
                <p>Ensure each list item in a mapped array has a unique and stable key prop to optimize rendering
                    performance. Keys help React identify which items have changed, been added, or removed, minimizing
                    unnecessary DOM updates.
                </p>
            </li>


            <li>
                <h2>CDN Integration</h2>
                <p>Serve static assets and resources from Content Delivery Networks (CDNs) to reduce latency and improve
                    reliability.</p>
            </li>

            <li>
                <h2>What is JWT?</h2>
                <p>JWT (JSON Web Token) is a compact, secure token format used for authentication and data exchange,
                    typically between a client and server. 🔐</p>
            </li>


            <li>
                <h2></h2>
                <p></p>
            </li>

            <li>
                <h2></h2>
                <p></p>
            </li>

            <li>
                <h2></h2>
                <p></p>
            </li>

            <li>
                <h2></h2>
                <p></p>
            </li>

            <li>
                <h2></h2>
                <p></p>
            </li>


        </ol>

        <div class="pagination">
            <button onclick="prevPage()">Previous</button>
            <span id="page-number">Page 1</span>
            <button onclick="nextPage()">Next</button>
        </div>
    </main>

    <!-- <script>
        //Pagination starts here//
        let currentPage = 1;
        const itemsPerPage = 10; // Show 10 items per page
        const items = document.querySelectorAll('.items li');
        const itemsArray = Array.from(items);
        const totalPages = Math.ceil(items.length / itemsPerPage);

        function showPage(page) {
            itemsArray.forEach((item, index) => {
                item.style.display = (index >= (page - 1) * itemsPerPage && index < page * itemsPerPage) ? "block" : "none";
            });
            document.getElementById("page-number").innerText = `Page${page}`;
        }
        function nextPage() {
            if (currentPage < totalPages) {
                currentPage++;
                showPage(currentPage);
            }
        }
        function prevPage() {
            if (currentPage > 1) {
                currentPage--;
                showPage(currentPage);
            }
        }
        showPage(currentPage);
        //Pagination ends here//
    </script> -->

</body>

</html>