<!DOCTYPE html>
<!-- declares the document type as HTML5, ensuring the browser renders the page in standards-compliant mode. -->
<!--HTML5 introduces modern features, better semantics, multimedia support, and cross-platform compatibility
for building robust web applications.-->
<html>

<head>
    <link rel="stylesheet" href="style.css">
    </link>
    <script src="index.js" defer></script>
    <!-- <script src="./JS files/PromiseAll.js" defer></script> -->
    <!-- <script src="./JS files/asynAwait.js" defer></script> -->

    <!-- <script src="destructuring.js" defer></script> -->
    <!-- <script src="forLoop.js" defer></script> -->
    <!-- <script src="closure.js" defer></script> -->
    <!-- <script src="objectMethod.js" defer></script> -->
    <!-- <script src="arrayMethod.js" defer></script> -->

    <!-- When you place the <script> tag in the <head> section, the script executes before the HTML elements 
        are fully loaded, so it cannot find or modify elements like <h1> because they don't exist in the DOM yet. -->
    <!-- The defer attribute in a <script> tag delays script execution until the HTML document is fully parsed,
        ensuring scripts run after the DOM is loaded. -->
    <!-- Defer ensurs scripts run after the DOM is loaded. -->
</head>

<body>
    <main class="container">
        <!-- <h1 id="h1">Hello, world!</h1>
        <h2 id="h2">Hello, world!</h2>
        <h2 class="h3">Hello, world!</h2>
        <h2 class="h3">Hello, world!</h2> -->
        <h2>https://api.freeapi.app/</h2>
        <h2>https://mockaroo.com/</h2>
        <ol class="items">
            <li>
                <h2>What is 'fs'? (asked in interview)</h2>
                <p>'fs' is a node.js built-in module for handling file system operations. </p>
            </li>

            <li>
                <h2>What is 'ajax'? (asked in interview)</h2>
                <p>'ajax' (Asynchronous Javascript and XML) It's a technique or a way for web-page for sending and
                    receiving data
                    from a server asynchronously w/o reloading the page. </p>
            </li>

            <li>
                <h2>What is 'API'? (asked in interview)</h2>
                <p>API (Application Programming Interface) is a set of rules that allows different software
                    applications to communicate with each other. </p>
                • example github user's api<br />
                • What it does:<br />
                • Sends a request to GitHub's API to get details of the user "octocat".<br />
                • Returns data like username, profile image, bio, and more in JSON format.<br />
                • How API Enables Communication:<br />
                • The food app (client) sends a request to Google Maps API (server).<br />
                • Google Maps API processes the request and returns a response with location data.<br />
                • The food app uses this response to show real-time restaurant locations.
            </li>

            <li>
                <h2>Difference b/w res.json() & res.send().</h2>
                <p>res.json() automatically sets the Content-Type to application/json and converts the response to JSON,
                    while res.send() can send any type of response (string, object, buffer, etc.). </p>
            </li>

            <li>
                <h2>Difference b/w req.body & req.params. (asked in interview)</h2>
                <p>req.body contains data sent in the request body (used in POST or PUT),
                    while req.params holds route parameters from the URL (e.g., /user/:id). </p>
            </li>

            <li>
                <h2>What is Node.js? (asked in interview)</h2>
                <p>Node.js is a runtime environment that allows you to run JavaScript on the server-side using the v8
                    engine.
                </p>
            </li>

            <li>
                <h2>What is runtime environment?</h2>
                <p>A runtime environment provides the necessary tools,
                    libraries, and execution context for running code outside its original development environment. </p>
            </li>

            <li>
                <h2>What is V8 engine?</h2>
                <p>The V8 engine is Google's high-performance JavaScript engine that compiles JavaScript into machine
                    code
                    for
                    faster execution. </p>
            </li>

            <li>
                <h2>How does Nodejs works? (asked in interview)</h2>
                <p>Node.js works by using the V8 engine to execute JavaScript code,
                    along with an event-driven,
                    non-blocking I/O model
                    to handle multiple requests efficiently.</p>
            </li>

            <li>
                <h2>What is event driven & non blocking I/O model? (asked in interview)</h2>
                <p>The event-driven, non-blocking I/O model in Node.js allows it to handle multiple requests
                    asynchronously
                    using callbacks,
                    Promises, or async/await,
                    without waiting for one task to complete before starting another.</p>
            </li>

            <li>
                <h2>How does Node.js handle asynchronous operations? (asked in interview)</h2>
                <p>Node.js handles asynchronous operations using an event loop,
                    callbacks, Promises,
                    and async/await,
                    enabling non-blocking execution for efficient performance. </p>
            </li>

            <li>
                <h2>What is Express.js? (asked in interview)</h2>
                <p>Express.js is a Node.js framework for building api and web servers.<br />
                    example - <br />
                    • creating basic server // const express = require('express'), app = express(); app.get('/', (req,
                    res) => res.send('Hello World')); app.listen(3000);<br />
                    • serving JSON // app.get('/api', (req, res) => res.json({ message: 'API response' }));<br />
                    • Route with parameters // app.get('/user/:id', (req, res) => res.send(`User ID:
                    ${req.params.id}`)); </p>
            </li>

            <li>
                <h2>How does jwt token works? (asked in interview)</h2>
                <p>Summary in Simple Terms<br />
                    The server creates a token, signs it with a secret key, and gives it to the client.<br />
                    The client sends the token back with each request.<br />
                    The server verifies the token to ensure it’s valid and processes the request.<br />
                    It’s like an ID card: the client shows it to prove who they are, and the server checks its
                    authenticity!</p>
            </li>

            <li>
                <h2>useEffect Dependency (asked in interview)</h2>
                <p>No dependency (useEffect(callback)) → Runs after every render.<br />
                    Empty array (useEffect(callback, [])) → Runs only once after the initial render, similar to
                    componentDidMount in class components.<br />
                    With dependencies (useEffect(callback, [dep1, dep2])) → Runs after the initial render and whenever
                    any dependency changes.</p>
            </li>

            <li>
                <h2>What next() does in a middleware? (asked in interview)</h2>
                <p>In middleware, next is a function that passes control to the next middleware in the stack; if not
                    called, the request will hang.</p>
            </li>

            <li>
                <h2>How does JWT authentication work in Node.js?</h2>
                <p>JWT authentication in Node.js works by generating a token with user data,
                    signing it with a secret, and then using that token to authenticate subsequent requests without
                    storing session data. 🚀
                </p>
            </li>

            <li>
                <h2>What is CORS, and how do you enable it in Node.js? (asked in interview)</h2>
                <p>CORS (Cross-Origin Resource Sharing) allows or restricts web applications from making requests to
                    domains outside their own,
                    and it can be enabled in Node.js using the cors middleware. 🚀</p>
            </li>


            <li>
                <h2>useMemo hook (asked in interview)</h2>
                <p>useMemo is a React hook that memoizes the result of a function,
                    preventing unnecessary recalculations and improving performance by only recomputing when
                    dependencies change. 🚀</p>
            </li>


            <li>
                <h2>What is TypeScript? (asked in interview)</h2>
                <p>
                    TypeScript is a superset of JavaScript that adds static typing and other features to enhance
                    development and code quality.<br />
                    - Key Points:<br />
                    <b>Static Typing</b>: In TypeScript, you can declare the data types of variables and function
                    parameters
                    (string, number, etc.).<br />
                    <b>Type Safety</b>: It helps catch errors at compile time instead of runtime, making your code more
                    reliable.
                </p>
            </li>

            <li>
                <h2>What is the difference between synchronous and asynchronous code in Node.js?</h2>
                <p>Synchronous code in Node.js executes tasks sequentially, blocking the next task until the current one
                    finishes,
                    while asynchronous code allows tasks to execute non-blocking and in parallel, improving performance.
                </p>
            </li>


            <li>
                <h2>Explain the concept of middleware in Express.js. (asked in interview)</h2>
                <p>Middleware is software that acts as a bridge,
                    processing requests and responses between the client and server or between different application
                    layers.
                </p>
            </li>

            <li>
                <h2>How do you handle errors in Node.js?</h2>
                <p>Errors in Node.js are handled using try...catch (for synchronous code),
                    .catch() (for Promises), and error-first callbacks or process.on('uncaughtException') for global
                    errors. </p>
            </li>

            <li>
                <h2>What is the difference between CommonJS and ES modules?</h2>
                <p>CommonJS (require/module.exports) is used in Node.js for synchronous module loading,
                    while ES Modules (import/export) support asynchronous loading and are the modern JavaScript
                    standard.</p>
            </li>

            <li>
                <h2>Event Loop (asked in interview)</h2>
                <p>The Event Loop in Node.js is a mechanism that handles asynchronous operations
                    by continuously checking and executing
                    pending tasks in the callback queue. 🚀</p>
            </li>

            <li>
                <h2>Does JS event loop and node.js event loop both are same?</h2>
                <p>The Node.js event loop has extra phases to manage asynchronous I/O, timers, and worker threads, while
                    the browser event loop primarily deals with UI rendering, event listeners, and network requests.</p>
            </li>

            <li>
                <h2>Difference b/w parameters & arguments.</h2>
                <p>- Parameters exist in function definitions.<br />
                    - Arguments are the real values passed when invoking a function.</p>
            </li>

            <li>
                <h2>useSelector? (asked in interview)</h2>
                <p>
                    useSelector is a React-Redux hook that selects and retrieves state from the Redux store in a
                    functional component.</p>
            </li>

            <li>
                <h2>body-parser? (asked in interview)</h2>
                <p>body-parser is a middleware in Express
                    that parses incoming request bodies in various formats (such as JSON, URL-encoded) and makes the
                    data accessible in req.body.</p>
            </li>

            <li>
                <h2>cookie-parser? (asked in interview)</h2>
                <p>cookie-parser is a middleware in Express that parses cookies
                    attached to the incoming requests and populates req.cookies with the cookies as key-value pairs.</p>
            </li>

            <li>
                <h2>payload?</h2>
                <p>A payload is the data or information sent in a request or response, often in the body of HTTP
                    requests or within a token like a JWT.</p>
            </li>

            <li>
                <h2>Axios vs fetch (asked in interview)</h2>
                <p>Axios and Fetch are HTTP clients used for making requests to servers.<br />
                    - Fetch is the native browser API, built in JS function => used to make http request => adhering to
                    modern promise-based standards.<br />
                    - Axios is a widely-used third-party library renowned for its concise syntax and extensive feature
                    set.<br />

                    - Axios is generally better due to its simplicity,
                    built-in features like automatic JSON parsing, request/response interceptors(Middleware), and
                    broader browser compatibility.
                    compared to Fetch.</p>
            </li>

            <li>
                <h2>Lexical scope (asked in interview)</h2>
                <p>Lexical scoping is a programming language feature where the scope of a variable is determined by its
                    position in the source code, and it is defined by the stucture of the code, not by the runtime flow
                    of the program.</p>
            </li>

            <li>
                <h2>Closure? (asked in interview)</h2>
                <p>A closure is a function that remembers and accesses variables from its outer scope, even after the
                    outer function has finished executing.<br />
                    this means the function has access to variables in its lexical environment.
                </p>
            </li>

            <li>
                <h2>Logistic Tracking System</h2>
                <p>- Implemented authentication using JWT & bcrypt.js,<br />
                    - handled authentication & protected routes using React Router,<br />
                    - and developed APIs using Express.js and Node.js.<br />
                    - Integrated real-time tracking with webSockets to display vehicle status, speed, and geofence
                    alerts efficiently.</p>
            </li>

            <li>
                <h2>Web sockets?</h2>
                <p>Web socket is a two-way communication channel protocol.<br />
                    between a web-browser & a server that allows real time data transfer like online chat, gaming,
                    live-streming.
                </p>
            </li>

            <li>
                <h2>Web hook?</h2>
                <p>A webhook is a user-defined http callback for event notifications, often
                    used in web-development for real time data transfer.
                </p>
            </li>

            <li>
                <h2>useState & useEffect (asked in interview)</h2>
                <p>useState - in functional component used for state management<br />
                    useEffect - It replaces react life cycle method in functional componenets & to handle side effects
                    for
                    api calls</p>
            </li>

            <li>
                <h2>app.use(express.json()) vs app.use(express.urlencoded({ extended: false }))</h2>
                <p>
                    <b>app.use(express.json())</b><br />
                    Parses incoming JSON requests.<br />
                    Required for handling Content-Type: application/json in POST/PUT requests.<br />

                    <b>app.use(express.urlencoded({ extended: false }))</b>
                    Parses application/x-www-form-urlencoded data (like form submissions).<br />
                    If extended: false, it only supports simple key-value pairs.<br />
                    If extended: true, it allows nested objects.
                </p>
            </li>

            <li>
                <h2>CSR vs SSR (asked in interview)</h2>
                <p>CSR - Client Side Rendering - React - slow //Server will provide raw data and client will process
                    that accordingly to screen sizes<br />
                    SSR - Server Side Rendering (Fast) - Google/Youtube //server will render itself html document</p>
            </li>

            <li>
                <h2>Method</h2>
                <p>A method is a function associated with an object that performs an action when invoked on that object.
                </p>
            </li>

            <li>
                <h2>Important Middleware Used in Industry-Level Node.js Applications</h2>
                <p>express.json() & express.urlencoded({ extended: true }) – Parses incoming JSON and URL-encoded data.
                    <br />
                    cors – Enables Cross-Origin Resource Sharing for APIs.<br />
                    helmet – Enhances security by setting HTTP headers.<br />
                    morgan – Logs HTTP requests for debugging and monitoring.<br />
                    compression – Compresses response data for better performance.<br />
                    cookie-parser – Parses cookies from client requests.<br />
                    express-session – Manages user sessions in applications.<br />
                    rate-limit – Implements request rate-limiting for security.<br />
                    passport – Handles authentication strategies like JWT, OAuth, etc.<br />
                    multer – Handles file uploads in APIs.<br />
                    error-handling middleware – Custom middleware to catch and handle errors globally.<br />
                    These are widely used in RESTful APIs, authentication, security, and performance optimization in
                    production-grade applications. 🚀
                </p>
            </li>

            <li>
                <h2>What are Recat hooks? (asked in interview)</h2>
                <p><b>React Hooks are functions that let you use state and lifecycle features</b> in functional
                    components
                    without writing a class.</p>
            </li>

            <li>
                <h2>What are the advantages of using hooks over class components?</h2>
                <p><b>Easier State Management</b> – useState, useEffect, etc., make managing state and side effects
                    simpler.<br />
                    <b>No this Keyword</b> – Avoids confusion caused by this in class components.<br />
                    <b>Reusability</b> – Custom hooks allow code reuse across components.<br />
                    <b>Improved Component Structure</b> – No need for lifecycle methods like componentDidMount,
                    componentDidUpdate, etc.
                </p>
            </li>

            <li>
                <h2>What is the `useState` hook? (asked in interview)</h2>
                <p>In functional componenet <b>used for state management</b>.</p>
            </li>

            <li>
                <h2>What is the `useEffect` hook? (asked in interview)</h2>
                <p>It replaces react life cycle method in functional componenets & handles side effects for
                    api calls</p>
            </li>

            <li>
                <h2>What are some use cases for `useEffect`?</h2>
                <p>useEffect is used for side effects like fetching data, updating the DOM, handling subscriptions, and
                    managing timers in React components.</p>
            </li>


            <li>
                <h2>What is `useContext` and how does it work? (asked in interview)</h2>
                <p>useContext is a React Hook that allows components to access and consume context values directly
                    without prop drilling.</p>
            </li>

            <li>
                <h2>What is the `useReducer` hook and when would you use it?</h2>
                <p>useReducer is a React Hook used for managing complex state logic by dispatching actions, often
                    preferred over useState for handling state transitions in large applications.</p>
            </li>

            <li>
                <h2> What is the `useMemo` hook? (asked in interview)</h2>
                <p>
                    useMemo is a React Hook that memoizes the result of a function to optimize performance by
                    recomputing only when dependencies change.</p>
            </li>

            <li>
                <h2>What is the React.memo()? (asked in interview)</h2>
                <p>React.memo() is a higher-order component that optimizes functional components by memoizing them,
                    preventing re-renders unless props change.</p>
            </li>

            <li>
                <h2> What is the `useCallback` hook?</h2>
                <p>
                    The useCallback hook memoizes a function to prevent unnecessary re-creations on every render,
                    improving performance in React components.</p>
            </li>

            <li>
                <h2>What are the rules of hooks?</h2>
                <p>The rules of hooks are: Only call hooks at the top level of a component<br />
                    Only call hooks from React function components</p>
            </li>

            <li>
                <h2>What is the `useRef` hook and how does it differ from `useState`?</h2>
                <p>
                    useRef creates a mutable reference to an element or value that persists across renders, while
                    useState stores a value that triggers re-rendering when updated.</p>
            </li>

            <li>
                <h2>What is `useLayoutEffect` and how is it different from `useEffect`?</h2>
                <p>useLayoutEffect is a React Hook that works similarly to useEffect, but it fires synchronously after
                    all DOM mutations and before the browser paints the screen. This means:<br />

                    It runs before the user sees any changes on the screen.<br />
                    <b>It blocks the rendering until it finishes execution.</b>
                </p>
            </li>

            <li>
                <h2>What are custom hooks in React? (asked in interview)</h2>
                <p>Custom hooks in React are reusable functions that encapsulate logic using React hooks (useState,
                    useEffect, etc.) to share stateful behavior across components. 🚀</p>
            </li>

            <li>
                <h2>What is `useImperativeHandle` and how does it work?</h2>
                <p>useImperativeHandle is a React hook that allows a parent component to customize and expose specific
                    methods of a child component's ref, controlling its behavior from outside. 🚀</p>
            </li>

            <li>
                <h2>What are Controlled vs Uncontrolled components? (asked in interview)</h2>
                <p>Controlled components: React controls the form state using useState (value & onChange).<br />
                    Uncontrolled components: The DOM handles the state using ref (defaultValue & useRef). 🚀</p>
            </li>

            <li>
                <h2>What is a Higher Order Component? (asked in interview)</h2>
                <p>A Higher Order Component (HOC) is a function that takes a component as input and returns a new
                    enhanced component with additional props or behavior. 🚀</p>
            </li>

            <li>
                <h2>What is a virtual DOM, how is it different from a real DOM and how it works? (asked in interview)
                </h2>
                <p>
                    The Virtual DOM (VDOM) is a lightweight, in-memory representation of the real DOM that React uses to
                    efficiently update only the changed parts, instead of re-rendering the entire UI, improving
                    performance. 🚀</p>
            </li>

            <li>
                <h2>What is the difference between componentDidMount and useEffect? (asked in interview)</h2>
                <p>componentDidMount is a class component lifecycle method that runs once after the component mounts,
                    while useEffect is a hook in functional components that can run after the render and optionally be
                    triggered on specific state/prop changes. 🚀</p>
            </li>

            <li>
                <h2>What is React fragments?</h2>
                <p>React Fragments (<></>) allow you to group multiple elements without adding an extra DOM node,
                    helping to return multiple children from a component without extra wrapper elements. 🚀</p>
            </li>

            <li>
                <h2>What is JSX? (asked in interview)</h2>
                <p>JSX is a syntax extension for JavaScript that allows you to write HTML-like code within JavaScript,
                    which React then compiles into React elements. 🚀</p>
            </li>

            <li>
                <h2>What is prop and what is prop drilling and what is solution to avoid prop drilling? (asked in
                    interview)</h2>
                <p>Props are data passed from a parent component to a child component; prop drilling is the process of
                    passing props through many layers of components, and the solution is to use Context API or state
                    management libraries (like Redux) to avoid unnecessary drilling. 🚀</p>
            </li>

            <li>
                <h2>What is Context in React?</h2>
                <p>Context in React is a way to share values (like state) across components without passing them
                    explicitly through each level of the component tree. 🚀</p>
            </li>

            <li>
                <h2>What are various ways to style a React app?</h2>
                <p>You can style a React app using CSS files, inline styles, CSS modules, styled-components, or tailwind
                    CSS. 🚀</p>
            </li>

            <li>
                <h2>What are render props in React?</h2>
                <p>Render props in React are a pattern where a component accepts a function as a prop to dynamically
                    render content, allowing code reuse and customization. 🚀</p>
            </li>

            <li>
                <h2>What is headers? (asked in interview)</h2>
                <p>
                    Headers are key-value pairs sent in HTTP requests or responses that provide metadata, such as
                    content type, authentication, or caching information. 🚀</p>
            </li>

            <li>
                <h2>Difeerence between git fetch and git pull. (asked in interview)</h2>
                <p>git fetch retrieves updates from a remote repository without merging them into the local branch,
                    while git pull fetches updates and automatically merges them into the local branch. 🚀</p>
            </li>


            <li>
                <h2>Why do we do npm init?</h2>
                <p>npm init is used to initialize a new Node.js project by creating a package.json file.</p>
            </li>

            <li>
                <h2>What is a Module in Node.js?</h2>
                <p>A module in Node.js is a reusable block of code that can be imported and exported between files to
                    keep the code organized and maintainable.</p>
            </li>

            <li>
                <h2>Explain the primary distinction between the Array.forEach() loop and Array.map() method, as well as
                    when to choose one over the other.</h2>
                <p><b>🔍 Array.forEach():</b><br />
                    It's a method that iterates over each element in an array and performs a specified action (callback
                    function) for each element.<br />
                    The main purpose of forEach() is to execute a function for its side effects, such as logging values,
                    updating variables, or performing operations on the array
                    elements without creating a new array.<br />
                    It does not return anything. It simply iterates over the array and executes the provided function
                    for each element.<br />
                    <b>Array.map():</b><br />
                    It's a method that iterates over each element in an array, applies a transformation function to each
                    element, and returns a new array containing the transformed
                    elements.<br />
                    The main purpose of map() is to create a new array with modified elements based on the original
                    array, without mutating the original array.<br />
                    It returns a new array with the same length as the original array, where each element is the result
                    of applying the provided function to the corresponding element
                    in the original array.
                </p>
            </li>

            <li>
                <h2>Polyfills (asked in interview)</h2>
                <p>Polyfills are code snippets that provide the implementation of certain functionality in older
                    JavaScript environments that do not support it natively.
                    JavaScript polyfills are essential for deep diving into how built-in methods work.<br />
                    Here’s how to approach writing polyfills like a pro:<br />
                    🔥 Step-by-Step Guide to Writing Polyfills:<br />

                    ✅ Identify Inputs & Outputs → What arguments does the method take? What should it return?<br />
                    ✅ Determine Ownership → Is it an Array, Object, Function, or Promise method?<br />
                    ✅ Understand the Logic → Analyze how the native method works.<br />
                    ✅ Draft a Skeleton → Structure your function before implementing logic.<br />
                    ✅ Test Use Cases → Write examples to verify the behavior.<br />
                    ✅ Write the Full Polyfill → Implement it from scratch.<br />
                    ✅ Compare with Native Methods → Ensure it matches native functionality.<br />
                    🏆 Must-Know Polyfills for Frontend Engineers<br />
                    🔥 Promise-based Polyfills:<br />
                    🔹 Promise.all<br />
                    🔹 Promise.allSettled<br />
                    🔹 Promise.race<br />
                    🔥 React-like Hooks Polyfills:<br />
                    🔹 useState<br />
                    🔹 useEffect<br />
                    🔹 useMemo<br />
                    🔹 Redux<br />
                    🔥 Essential JS Methods:<br />
                    🔹 Function.bind<br />
                    🔹 Array.reduce<br />
                    🔹 Object.freeze & Object.seal<br />
                    🔹 Debounce & Throttle<br />
                    🔥 Advanced:<br />
                    🔹 Custom setInterval (Stop, Resume, Pause)<br />
                    🔹 Polyfill for new keyword<br />
                    🔹 Function Memoization (Cache results & optimize performance)
                </p>
            </li>

            <li>
                <h2>Polyfill for Promise.all with Example (asked in interview)</h2>
                <p>The Promise.all method takes an array of promises and resolves when all of them are resolved. If any
                    promise fails, it rejects immediately.</p>
            </li>

            <li>
                <h2>What is API call? (asked in interview)</h2>
                <p>An API call is a request made by a client to a server to retrieve or send data, typically over HTTP
                    using methods like GET, POST, PUT, or DELETE.</p>
            </li>


            <li>
                <h2>Definition and key difference of Promise.all, Promise.allSetteled, Promise.race and Promise.any.
                </h2>
                <p><b>Promise.all</b> → Resolves when all promises succeed, rejects immediately if any fail.<br />
                    <b>Promise.allSettled</b> → Waits for all promises to settle (either resolve or reject), always
                    returns an array of results.<br />
                    <b>Promise.race</b> → Resolves or rejects as soon as the first promise settles, ignoring
                    others.<br />
                    <b>Promise.any</b> → Resolves when any one promise succeeds, rejects only if all fail.
                </p>
            </li>

            <li>
                <h2>In which scenarios do error boundaries not catch errors? </h2>
                <p>Error boundaries do not catch errors inside event handlers, asynchronous code (e.g., setTimeout,
                    fetch), server-side rendering (SSR), or errors thrown inside the error boundary itself.</p>
            </li>


            <li>
                <h2>What is error boundary?</h2>
                <p>An error boundary is a React component that catches JavaScript errors in its child components during
                    rendering, lifecycle methods, and constructors, preventing the entire app from crashing.
                </p>
            </li>


            <li>
                <h2>Can you describe the `componentDidCatch` lifecycle method?</h2>
                <p>The componentDidCatch lifecycle method in React is used inside error boundaries to catch JavaScript
                    errors in child components and log or handle them gracefully.
                </p>
            </li>


            <li>
                <h2>What is the proper placement for error boundaries? </h2>
                <p>Error boundaries should be placed around critical UI components, such as layouts, routes, widgets,
                    and third-party components, to prevent the entire app from crashing.
                </p>
            </li>


            <li>
                <h2>Use case of all promises Promise.all, Promise.allSetteled, Promise.race and Promise.any</h2>
                <p><b>Promise.all</b> → Fetching data from multiple APIs (e.g., user info, posts, comments) where all
                    responses
                    are required.<br />
                    <b>Promise.allSettled</b> → Running multiple analytics events where failures should be logged but
                    not break
                    the process.<br />
                    <b>Promise.race</b> → Implementing a timeout for API requests by racing the request against a
                    fallback
                    timeout promise.<br />
                    <b>Promise.any</b> → Fetching data from multiple redundant servers and using the fastest successful
                    response.
                </p>
            </li>


            <li>
                <h2>Code Splitting</h2>
                <p>Break down large bundles into smaller chunks to reduce initial load times<br />
                    Code splitting is a technique to dynamically load JavaScript only when needed, improving
                    performance.
                </p>
            </li>


            <li>
                <h2>Lazy Loading</h2>
                <p>Load non-essential components\asynchronously to prioritize critical content.
                </p>
            </li>



            <li>
                <h2>Caching and Memoization</h2>
                <p>Cache data locally or use memoization libraries to avoid redundant API calls and computations.
                </p>
            </li>


            <li>
                <h2>Memoization</h2>
                <p>Memoize expensive computations and avoid unnecessary re-renders using tools like React.memo and
                    useMemo.
                </p>
            </li>


            <li>
                <h2>Optimized Rendering</h2>
                <p>Use shouldComponentUpdate, PureComponent, or React.memo to prevent unnecessary re-renders of
                    components.
                </p>
            </li>


            <li>
                <h2>Pure function</h2>
                <p>A pure function is a function that always returns the same output for the same input and has no side
                    effects (does not modify external state). 🚀<br />
                    A pure function does not rely on or modify global variables, ensuring that its output depends only
                    on its input parameters, making it predictable and testable. 🚀
                </p>
            </li>


            <li>
                <h2>Pure Component (asked in interview)</h2>
                <p>A Pure Component in React is a component that only re-renders when its state or props change, using
                    shallow comparison to optimize performance. 🚀
                </p>
            </li>


            <li>
                <h2>Virtualization</h2>
                <p> Implement virtual lists and grids to render only the visible elements, improving rendering
                    performance for large datasets.
                </p>
            </li>


            <li>
                <h2>Server-Side Rendering (SSR)</h2>
                <p>Pre-render content on the server to improve initial page load times and enhance SEO.
                </p>
            </li>


            <li>
                <h2>Bundle Analysis</h2>
                <p>Identify and remove unused dependencies, optimize images, and minify code to reduce bundle size.
                </p>
            </li>


            <li>
                <h2>Performance Monitoring</h2>
                <p>Continuously monitor app performance using tools like Lighthouse, Web Vitals, and browser DevTools.
                </p>
            </li>


            <li>
                <h2>Optimize rendering with keys</h2>
                <p>Ensure each list item in a mapped array has a unique and stable key prop to optimize rendering
                    performance. Keys help React identify which items have changed, been added, or removed, minimizing
                    unnecessary DOM updates.
                </p>
            </li>


            <li>
                <h2>CDN Integration</h2>
                <p>Serve static assets and resources from Content Delivery Networks (CDNs) to reduce latency and improve
                    reliability.</p>
            </li>

            <li>
                <h2>What is JWT?</h2>
                <p>JWT (JSON Web Token) is a compact, secure token format used for authentication and data exchange,
                    typically between a client and server. 🔐</p>
            </li>


            <li>
                <h2>Stateful and stateless definition in session context</h2>
                <p>
                    <b>Stateful Session</b>: A session where the server stores user data (like authentication state)
                    across
                    requests (e.g., session-based authentication with Express & express-session).<br />
                    <b>Stateless Session</b>: A session where the server does not store user data, and each request must
                    include authentication credentials (e.g., JWT-based authentication). 🚀
                </p>
            </li>

            <li>
                <h2>Stateful and stateless componenet definition</h2>
                <p><b>Stateful</b>: A component or system that maintains internal state and updates it over time (e.g.,
                    React component using useState).<br />
                    <b>Stateless</b>: A component or system that does not store any state and relies only on props or
                    input (e.g., a pure function or a functional React component without state). 🚀
                </p>
            </li>

            <li>
                <h2>Core Concepts and Terminology of Async/Await,Promise, Callback</h2>
                <p>
                    Async: Asynchronous, meaning the function does not block the execution of the code.<br />
                    Await: A keyword used to pause the execution of the code until the promise is resolved or
                    rejected.<br />
                    Promise: A result object that is used to handle asynchronous operations.<br />
                    Callback: A function passed as an argument to another function, used to handle asynchronous
                    operations.</p>
            </li>

            <li>
                <h2>How it Works Under the Hood async/await</h2>
                <p>When you use async/await, the JavaScript engine creates a promise that is resolved or rejected when
                    the asynchronous operation is complete. The await keyword pauses the execution of the code until the
                    promise is resolved or rejected.</p>
            </li>

            <li>
                <h2>What is exception</h2>
                <p>In programming, an exception is an event that disrupts the normal flow of a program's instructions,
                    typically due to an error or unexpected condition.</p>
            </li>


            <li>
                <h2>Why nextjs over react?</h2>
                <p>Server-Side Rendering (SSR) and Static Site Generation (SSG)<br />
                    File-Based Routing<br />
                    Automatic Code Splitting<br />
                    Built-In API Routes<br />
                    Enhanced Performance and SEO
                </p>
            </li>

            <li>
                <h2>JS Exceution Context</h2>
                <p>JS Exceution Context is divided into two parts <b>memory component (Variable Environment)</b> &
                    <b>code component (Thread of execution)</b>.<br />
                    1st part stores variable in key,value format & function.<br />
                    2nd part execute JS code line by line.

                </p>
            </li>


            <li>
                <h2>Closure</h2>
                <p>A function with its lexical scope bundles together form a closure.</p>
            </li>


            <li>
                <h2>Promise</h2>
                <p>A promise is an object represnting the eventual completion or failure of an async operation.</p>
            </li>


            <li>
                <h2>emmet</h2>
                <p><b>It's a plugin for text editors</b> that enhances HTML, CSS, and XML workflow by allowing
                    developers <b>to write abbreviations that expand into structured code</b>, significantly improving
                    coding speed and efficiency.
                    It supports dynamic snippets, custom expansion and multiple cursor editing, making it a powerful
                    tool for front-end-developers.<br />
                    Emmet is the essential toolkit for web-developers. It allows you
                    to type shortcuts that are then expanded into full-fledged
                    boiler plate code for writing HTML and CSS
                </p>
            </li>


            <li>
                <h2>What is CDN? Why do we use it?</h2>
                <p>It's a Content Delievery Network in react refers to a network where React libraries or dependencies
                    are hoisted, allowing us to load them directly into our project via URL's instead of installing them
                    locally.</p>
            </li>


            <li>
                <h2>What is crossorigin in script tag?</h2>
                <p>The crossorigin attribute in a script tag from a React CDN link controls how the browser handles CORS
                    request, ensuring proper loading and error handling of externl scripts. </p>
            </li>


            <li>
                <h2>Difference between a Library and Framework?</h2>
                <p>Library is a collections of prewritten code snippets that can
                    be used and reused to perform certain tasks. A particular
                    JavaScript library code can be plugged into application code
                    which leads to faster development and fewer vulnerabilities to
                    have errors.
                    Examples: React, jQuery<br />
                    Framework provides a basic foundation or structure for a
                    website or an application.
                    Examples: Angular
                </p>
            </li>


            <li>
                <h2>Why is React known as React?</h2>
                <p>React is named for its ability to "react" efficiently to data changes, updating the user interface
                    dynamically.</p>
            </li>


            <li>
                <h2>What is diference between React and ReactDOM?</h2>
                <p>React is a JavaScript library for building user interfaces, while ReactDOM is a library that enables
                    React to interact with the browser's Document Object Model (DOM). </p>
            </li>

            <li>
                <h2>What is difference between react.development.js and react.production.js files via CDN?</h2>
                <p>The react.development.js file includes helpful warnings and error messages for debugging during
                    development, while the react.production.js file is optimized for performance by removing these
                    warnings and enabling other optimizations for production environments.</p>
            </li>


            <li>
                <h2>What is async and defer?</h2>
                <p>In HTML, the async attribute allows a script to download in parallel with the page and execute as
                    soon as it's ready, potentially before the HTML parsing is complete, while the defer attribute also
                    downloads the script in parallel but ensures it executes only after the HTML parsing is finished.
                </p>
            </li>

            <li>
                <h2>Similarities between Library and Framework?</h2>
                <p>Frameworks and libraries are code written by third parties to
                    solve regular/common problems or to optimise performance.</p>
            </li>


            <li>
                <h2>Difference between Library and Framework?</h2>
                <p>A key difference between the two is Inversion of control. When
                    using a library, the control remains with the developer who
                    tells the application when to call library functions. When
                    using a framework, the control is reversed, which means that
                    the framework tells the developer where code needs to be
                    provided and calls it as it requires.
                </p>
            </li>

            <li>
                <h2>crossorigin?</h2>
                <p>The crossorigin attribute in the script tag enables CrossOrigin Resource Sharing (CORS) for loading
                    external JavaScript
                    files from different origin than the hosting web page. This
                    allows the script to access resources from the server hosting
                    the script, such as making HTTP requests or accessing data.
                </p>
            </li>


            <li>
                <h2>React.CreateElement parameter {}</h2>
                <p>This (id='title'), classes, etc should come under {}. Whenever
                    I'm passing inside {}, will go as tag attributes of h1.</p>
            </li>


            <li>
                <h2>What is node?</h2>
                <p>A node is any individual part of a webpage, such as an element, text, or attribute, forming the
                    building blocks of the page's structure.
                </p>
            </li>


            <li>
                <h2>Inception</h2>
                <p>"Inception" refers to the beginning or start of something.</p>
            </li>


            <li>
                <h2>To make our app production ready what should we do?</h2>
                <p>Minify our file (Remove console logs, bundle things up)
                    Need a server to run things.<br />
                    <b>📢 NOTE: Minify —> Optimization —>Clean console —> Bundle</b>
                </p>
            </li>


            <li>
                <h2>Bundlers</h2>
                <p>A bundler is a tool that <b>bundles our app, packages our app so
                        that it can be shipped to production.</b><br />
                    Examples of Bundlers:<br />
                    Webpack<br />
                    Vite<br />
                    Parcel<br />
                    NOTE: In create-react-app, the bundler used is webpack.
                </p>
            </li>


            <li>
                <h2>Package Manager</h2>
                <p>Bundlers are packages. If we want to use a package in our
                    code, we have to use a package manager.<br />
                    We use a package manager known as npm or yarn</p>
            </li>

            <li>
                <h2>npm init</h2>
                <p>It creates a package.json file.<br />
                    Now to install parcel we will do:<br />
                    npm install -D parcel<br />
                    Now we will get a package-lock.json file.</p>
            </li>

            <li>
                <h2>package.json</h2>
                <p>Package.json file is a configuration for NPM. Whatever
                    packages our project needs, we install those packages using
                    npm install <packageName>.<br />
                        Once package installation is complete, their versions and
                        configuration related information is stored as dependencies
                        inside package.json file.</p>
            </li>

            <li>
                <h2>package-lock.json</h2>
                <p>Package-lock.json locks the exact version of packages being
                    used in the project.</p>
            </li>


            <li>
                <h2>What is difference between package.json and
                    package.lock.json?
                </h2>
                <p>In package. json we have information about <b>generic version</b>
                    of installed packages whereas in package.lock.json we have
                    information about the specific or exact version of
                    installed packages.</p>
            </li>


            <li>
                <h2>node_modules</h2>
                <p>Which gets installed is like a database for the npm.<br />
                    Every dependency in node_module will have its package.json.<br />
                    Node modules are very heavy so we should always put this in
                    gitignore.</p>
            </li>


            <li>
                <h2>npx parcel index.html</h2>
                <p>npx means ‘execute using npm’
                    index.html is the entry point.<br />
                    This will create a faster development version of our project
                    and serves it on the server.<br />
                </p>
            </li>

            <li>
                <h2>npx parcel build index.html</h2>
                <p>It creates a lot of things, minify your file.<br />
                    And the parcel will build all the production files to
                    the dist folder.</p>
            </li>

            <li>
                <h2>Hot Module Replacement (HMR)</h2>
                <p>It means that parcel will keep a track of all the files which
                    you are updating.<br />
                    There is File Watcher Algorithm (written in C++).<br />
                    <b>It keeps
                        track of all the files which are changing realtime</b> and it
                    tells the server to reload.<br />
                    These are all done by PARCEL
                </p>
            </li>

            <li>
                <h2>parcel-cache</h2>
                <p>Parcel caches code all the time.<br />
                    When we run the application, a build is created which takes
                    some time in ms.<br />
                    If we make any code changes and save the application, another
                    build will be triggered which might take even less time than
                    the previous build.<br />
                    This reduction of time is due to parcel cache.<br />
                    Parcel immediately loads the code from the cache every time
                    there is a subsequent build.<br />
                    On the very first build parcel creates a folder .parcelcache where it stores the caches in binary
                    codeformat.<br />
                    Parcel gives <b>faster build, faster developer experience
                        because of caching.</b></p>
            </li>

            <li>
                <h2>Transitive Dependencies</h2>
                <p>We have our package manager which takes care of our
                    transitive dependencies of our code.<br />
                    If we’ve to build a production ready app which uses all
                    optimisations (like minify, bundling, compression, etc), we
                    need to do all these.<br />
                    But we can’t do this alone, we need some dependencies on it.
                    Those dependencies are also dependent on other dependencies.</p>
            </li>

            <li>
                <h2>Parcel feature at a glance</h2>
                <p>
                    - <b>Hot Module Replacement (HMR)</b><br />
                    - File Watcher Algorithm - C++<br />
                    - Bundling<br />
                    - Minify Code<br />
                    - Cleaning our code<br />
                    - Dev and production build<br />
                    - Super fast build algorithm<br />
                    - Image Optimization<br />
                    - Caching while development<br />
                    - Compression<br />
                    - Compatible with older browser versions<br />
                    - Https on dev<br />
                    - Image Optimization<br />
                    - Port No<br />
                    - Consistency Hashing Algorithm<br />
                    - Zero Config<br />
                    - <b>Tree Shaking</b>
                </p>
            </li>

            <li>
                <h2>Browserslist:</h2>
                <p> Browserslist is a tool that specifies which browsers should
                    be supported/compatible in your frontend app.<br />
                    It makes our code compatible for a lot of browsers.<br />
                    In package.json file do:<br />
                    <b>"browserslist":["last 2 versions"]</b><br />
                    support 74% all browsers<br />
                    This means my parcel will make sure that my app works in last 2 version of all the browsers
                    avilable.
                </p>
            </li>

            <li>
                <h2> Tree Shaking:</h2>
                <p> Tree shaking is a <b>process of removing the unwanted code</b> that
                    we do not use while developing the application.<br />
                    In computing, tree shaking is a dead code elimination
                    technique that is applied when optimizing code.
                </p>
            </li>

            <li>
                <h2>dist:</h2>
                <p>It keeps the files minified for us.<br />
                    When bundler builds the app, the build goes into a folder
                    called dist.<br />
                    The `/dist` folder contains the <b>minimized and optimised
                        version the source code.</b><br />
                    Along with the minified code, the /dist folder also comprises
                    of all the compiled modules that may or may not be used with
                    other systems.
                </p>
            </li>

            <li>
                <h2>JSX</h2>
                <p>We used React.createElement() for displaying content
                    on the webpage but its syntax is very bad. It’s not developer
                    friendly, and very hard to read. To solve this problem Facebook
                    developers built JSX.<br />
                    JSX makes developer life easy as we no longer have to write our
                    code using React.createElement()<br />
                </p>
            </li>


            <li>
                <h2>What is JSX?</h2>
                <p>JSX is <b>HTML-like or XML-like syntax</b>. JSX stands for JavaScript
                    XML. It's a syntax extension for JavaScript.<br />
                    It is not a part of React. React apps can be built even
                    without JSX but the code will become very hard to read.<br />
                    It is not HTML inside JavaScript.<br />
                    JavaScript engine cannot understand JSX as it only
                    understands ECMAScript.
                </p>
            </li>


            <li>
                <h2> Is JSX a valid JavaScript?</h2>
                <p>JSX is not a valid Javascript syntax as it’s not pure HTML or
                    pure JavaScript for a browser to understand. JS does not have
                    built-in JSX. The JS engine does not understand JSX because
                    the <b>JS engine understands ECMAScript or ES6+ code.</b></p>
            </li>


            <li>
                <h2> If the browser can’t understand JSX how is it still working?</h2>
                <p>This is because of Parcel because “Parcel is a Beast”.<br />
                    Before the code gets to JS Engine it is sent to Parcel and
                    Transpiled there. Then after transpilation, the browser gets the
                    code that it can understand.<br />
                    Transpilation
                    ⇒
                    Converting the code in such a format that the
                    browsers can understand.<br />
                    Parcel is like a manager who gives the responsibility of
                    transpilation to a package called Babel.<br /><br />
                    Babel is a package that is a compiler/transpiler of JavaScript
                    that is already present inside ‘node-modules’. It takes JSX and
                    converts it into the code that browsers understand, as soon as
                    we write it and save the file. It is not created by Facebook. <br /><br />
                    <b>
                        JSX (transpiled by Babel)
                        ⇒
                        React.createElement
                        ⇒
                        ReactElement
                        ⇒
                        JS Object
                        ⇒
                        HTML Element(render)
                    </b>

                </p>
            </li>

            <li>
                <h2> What is the difference between HTML and JSX?</h2>
                <p>JSX is not HTML. It’s HTML-like syntax.<br />
                    HTML uses ‘class’ property whereas JSX uses ‘className’
                    property.<br />
                    HTML can use hypens in property names whereas JSX uses
                    camelCase syntax.
                </p>
            </li>


            <li>
                <h2> What is a React Functional Components?</h2>
                <p>It is just a JavaScript Function that returns some JSX or a
                    react element.</p>
            </li>


            <li>
                <h2> Advantages of using JSX.</h2>
                <p>JSX prevents code injections (attacks)<br />
                    JSX makes it easier to write code as we are no longer creating
                    elements using React.createElement()<br /><br />
                    If someone gets access to your JS code and sends some malicious
                    data which will then get displayed on the screen, that attack is
                    called cross-site scripting.
                    It can read cookies, local storage, session storage, get
                    cookies, get info about your device, and read data. JSx takes
                    care of your data.
                    If some API passes some malicious data JSX will escape it. It
                    prevents cross-site scripting and sanitizes the data before
                    rendering
                </p>
            </li>


            <li>
                <h2>Config Driven UI.</h2>
                <p>It is a user Interface that is built and configured using a
                    declaration configuration file or data structure, rather than
                    being hardcoded.<br />
                    Config is the data coming from the api which keeps on changing
                    according to different factors like user, location, etc. </p>
            </li>


            <li>
                <h2> Why do we use React? Some of us might wonder why we don't
                    just stick to HTML, CSS, and JAVASCRIPT for everything we've
                    been doing?</h2>
                <p> Of course! It's absolutely possible to accomplish
                    everything using regular HTML, CSS and JAVASCRIPT without
                    using REACT. However, we chose React because it enhances
                    our developer experience, making it more seamless and
                    efficient.</p>
            </li>


            <li>
                <h2>Note</h2>
                <p> 📢
                    NOTE: - The crucial point about State variables is that
                    whenever they update, React triggers a reconciliation
                    cycle and re-renders the component. - This means that as soon as the data layer changes,
                    React promptly updates the UI layer. The data layer is
                    always kept in sync with the UI layer. - To achieve this rapid operation, React employs a
                    reconciliation algorithm, also known as the diffing
                    algorithm or React-Fibre which we will delve into further
                    below.</p>
            </li>

            <li>
                <h2> What are ‘Monolithic’ and ‘Microservices’ architectures exactly?</h2>
                <p>
                    Understanding ‘Monolith’ and ‘Microservices’ architectures is a big deal in
                    software development, but as developers, it's important to grasp the basics. So,
                    in this episode, we'll break it down into simple terms.<br />
                    In the past, we used to build large projects where everything was bundled
                    together. Imagine building an entire application where all the code—APIs, user
                    interface, database connections, authentication, even notification services—
                    resides in one massive project with single code base.<br /><br />
                    The idea is to split your application into a set of smaller, interconnected
                    services instead of building a single monolithic application. Each service handles
                    a specific job, like handling user accounts or managing payments. Inside each
                    service, there's a mini-world of its own, with its own set of rules (business
                    logic) and tools (adapters). Some services talk to each other in different ways,
                    like using REST or messaging. Others might even have their own website!
                </p>
            </li>

            <li>
                <h2> Why Microservices?</h2>
                <p> Breaking things down into microservices helps us work faster and smarter. We
                    can update or replace each piece without causing a fuss. It's like having a well
                    oiled machine where each part does its job perfectly.</p>
            </li>

            <li>
                <h2> How do these services interact with each other?</h2>
                <p> Ports and Domain Mapping
                    Each microservice runs on its specific port. This means that different services 
                   can be deployed independently, with each one assigned to a different port. All 
                   these ports are then mapped to a domain name, providing a unified access point for 
                   the entire application.</p>
            </li>

            <li>
                <h2>What is Parcel?</h2>
                <p>Parcel takes your files (like HTML, CSS, JS) and bundles them together so they work in the browser.</p>
            </li>

            <li>
                <h2></h2>
                <p></p>
            </li>


            <li>
                <h2></h2>
                <p></p>
            </li>

            <li>
                <h2></h2>
                <p></p>
            </li>

            <li>
                <h2></h2>
                <p></p>
            </li>

            <li>
                <h2></h2>
                <p></p>
            </li>


            <li>
                <h2></h2>
                <p></p>
            </li>


            <li>
                <h2></h2>
                <p></p>
            </li>


            <li>
                <h2></h2>
                <p></p>
            </li>


            <li>
                <h2></h2>
                <p></p>
            </li>


            <li>
                <h2></h2>
                <p></p>
            </li>

            <li>
                <h2></h2>
                <p></p>
            </li>


            <li>
                <h2></h2>
                <p></p>
            </li>

        </ol>


        <div class="pagination">
            <button onclick="prevPage()">Previous</button>
            <span id="page-number">Page 1</span>
            <button onclick="nextPage()">Next</button>
        </div>
    </main>

    <!-- <script>
        //Pagination starts here//
        let currentPage = 1;
        const itemsPerPage = 10; // Show 10 items per page
        const items = document.querySelectorAll('.items li');
        const itemsArray = Array.from(items);
        const totalPages = Math.ceil(items.length / itemsPerPage);

        function showPage(page) {
            itemsArray.forEach((item, index) => {
                item.style.display = (index >= (page - 1) * itemsPerPage && index < page * itemsPerPage) ? "block" : "none";
            });
            document.getElementById("page-number").innerText = `Page${page}`;
        }
        function nextPage() {
            if (currentPage < totalPages) {
                currentPage++;
                showPage(currentPage);
            }
        }
        function prevPage() {
            if (currentPage > 1) {
                currentPage--;
                showPage(currentPage);
            }
        }
        showPage(currentPage);
        //Pagination ends here//
    </script> -->

</body>

</html>